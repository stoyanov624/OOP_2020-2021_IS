# Динамичен контейнер
### От УП-то винаги сме искали да имаме масив с безброй много елементи, с лесно добяване и премахване на елементи и присвояване на един масив на друг само с оператор =. Ами по ООП можем сами да го създадем. За примерите ще се инициализира контейнер от цели числа, но имплементацията е аналогична за всякакъв тип данни (double, char, други обекти и т.н).
  

## size_t  
### Това е unsigned int, подходящо е да се използва когато имаме размери, капацитети и дължини, тъй като допустимите стойности на size_t са > 0. (няма отрицателни стойности).Също ни се гарантира, че големината на size_t може да побере най - големия обект, който системата ни може да понесе. 
```c++
class IntegerVector {
private:
    int* vector;
    size_t size; // ще определя колко инициализирани елемента имаме
    size_t capacity // ще определя колко място ще имаме за елементи

    // вече трябва да знаете как се имплементира голяма 4, copy и erase :)
    void copy(const IntegerVector& other_vector) {
        ...
    }
    void erase() {
        ...
    }

    void resize() { // този помощен метод трябва да се викна точно когато има вероятност капацитета ни да бъде надхвърлен.
        this->capacity *= 2; // удвояваме капацитета
	    int bigger_Buffer = new int[this->capacity]; // създаваме си нов масив с новия капацитет.

	    for (size_t i = 0; i < this->size; i++)
	    {
		    bigger_Buffer[i] = this->vector[i]; // презаписваме си данните от нашия масив, за да не ги изгубим
	    }
        delete[] this->vector; // освобождаваме паметта от нашия масив.
        this->vector = bigger_Buffer; // пренасочваме указателя на нашия масив да сочи към този с удвоения капацитет.
    }

public:
     // при всеки конструктор трябва да заделим памет колко ще ни бъде капацитета
     // Пример с дефолтния конструктор
    IntegerVector() {
        this->capacity = 10; // хубаво е да почнем с малко число и при нужда ще го направим по - голямо
        this->size = 0; // тъй като при извикване на конструктор нашия обект се ражда е логично размера от инициализирани клетки да е 0
        this->vector = new int[this->capacity];
    }
    IntegerVector(const IntegerVector& other_vector) {
        this->copy(other);
    }

    IntegerVector& operator=(const IntegerVector& other_vector) {
        if(this != &other_vector) {
            this->erase();
            this->copy(other_vector);
        }
        return *this;
    }

    ~IntegerVector() {
        this->erase();
    }

    void push_back(int new_element) { // ще добавим нов елемент в края на масива.
        // трябва да проверим дали имаме място за новия елемент, ако нямаме място ще излезнем извън допустимите стойности на вектора
        if(this->size >= this->capacity) { 
            this->resize(); // помощна функция, която ще удвои капацитета на вектора.
        }
        this->vector[size] = new_element; // this->vector[size] ни дава последния неинициализиран елемент.
        this->size++; // при добавяне на елемент размера трябва да се увеличи.
    }
};
```